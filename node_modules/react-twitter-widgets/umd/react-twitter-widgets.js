/*!
 * react-twitter-widgets v1.11.0 - https://github.com/andrewsuzuki/react-twitter-widgets
 * MIT Licensed
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["ReactTwitterWidgets"] = factory(require("react"));
	else
		root["ReactTwitterWidgets"] = factory(root["React"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__0__;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(this, function() {
/**
 * Global dependencies.
 * @global {Object} document - DOM
 */

var devnull = function() {},
    bundleIdCache = {},
    bundleResultCache = {},
    bundleCallbackQueue = {};


/**
 * Subscribe to bundle load event.
 * @param {string[]} bundleIds - Bundle ids
 * @param {Function} callbackFn - The callback function
 */
function subscribe(bundleIds, callbackFn) {
  // listify
  bundleIds = bundleIds.push ? bundleIds : [bundleIds];

  var depsNotFound = [],
      i = bundleIds.length,
      numWaiting = i,
      fn,
      bundleId,
      r,
      q;

  // define callback function
  fn = function (bundleId, pathsNotFound) {
    if (pathsNotFound.length) depsNotFound.push(bundleId);

    numWaiting--;
    if (!numWaiting) callbackFn(depsNotFound);
  };

  // register callback
  while (i--) {
    bundleId = bundleIds[i];

    // execute callback if in result cache
    r = bundleResultCache[bundleId];
    if (r) {
      fn(bundleId, r);
      continue;
    }

    // add to callback queue
    q = bundleCallbackQueue[bundleId] = bundleCallbackQueue[bundleId] || [];
    q.push(fn);
  }
}


/**
 * Publish bundle load event.
 * @param {string} bundleId - Bundle id
 * @param {string[]} pathsNotFound - List of files not found
 */
function publish(bundleId, pathsNotFound) {
  // exit if id isn't defined
  if (!bundleId) return;

  var q = bundleCallbackQueue[bundleId];

  // cache result
  bundleResultCache[bundleId] = pathsNotFound;

  // exit if queue is empty
  if (!q) return;

  // empty callback queue
  while (q.length) {
    q[0](bundleId, pathsNotFound);
    q.splice(0, 1);
  }
}


/**
 * Execute callbacks.
 * @param {Object or Function} args - The callback args
 * @param {string[]} depsNotFound - List of dependencies not found
 */
function executeCallbacks(args, depsNotFound) {
  // accept function as argument
  if (args.call) args = {success: args};

  // success and error callbacks
  if (depsNotFound.length) (args.error || devnull)(depsNotFound);
  else (args.success || devnull)(args);
}


/**
 * Load individual file.
 * @param {string} path - The file path
 * @param {Function} callbackFn - The callback function
 */
function loadFile(path, callbackFn, args, numTries) {
  var doc = document,
      async = args.async,
      maxTries = (args.numRetries || 0) + 1,
      beforeCallbackFn = args.before || devnull,
      pathname = path.replace(/[\?|#].*$/, ''),
      pathStripped = path.replace(/^(css|img)!/, ''),
      isLegacyIECss,
      e;

  numTries = numTries || 0;

  if (/(^css!|\.css$)/.test(pathname)) {
    // css
    e = doc.createElement('link');
    e.rel = 'stylesheet';
    e.href = pathStripped;

    // tag IE9+
    isLegacyIECss = 'hideFocus' in e;

    // use preload in IE Edge (to detect load errors)
    if (isLegacyIECss && e.relList) {
      isLegacyIECss = 0;
      e.rel = 'preload';
      e.as = 'style';
    }
  } else if (/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(pathname)) {
    // image
    e = doc.createElement('img');
    e.src = pathStripped;    
  } else {
    // javascript
    e = doc.createElement('script');
    e.src = path;
    e.async = async === undefined ? true : async;
  }

  e.onload = e.onerror = e.onbeforeload = function (ev) {
    var result = ev.type[0];

    // treat empty stylesheets as failures to get around lack of onerror
    // support in IE9-11
    if (isLegacyIECss) {
      try {
        if (!e.sheet.cssText.length) result = 'e';
      } catch (x) {
        // sheets objects created from load errors don't allow access to
        // `cssText` (unless error is Code:18 SecurityError)
        if (x.code != 18) result = 'e';
      }
    }

    // handle retries in case of load failure
    if (result == 'e') {
      // increment counter
      numTries += 1;

      // exit function and try again
      if (numTries < maxTries) {
        return loadFile(path, callbackFn, args, numTries);
      }
    } else if (e.rel == 'preload' && e.as == 'style') {
      // activate preloaded stylesheets
      return e.rel = 'stylesheet'; // jshint ignore:line
    }
    
    // execute callback
    callbackFn(path, result, ev.defaultPrevented);
  };

  // add to document (unless callback returns `false`)
  if (beforeCallbackFn(path, e) !== false) doc.head.appendChild(e);
}


/**
 * Load multiple files.
 * @param {string[]} paths - The file paths
 * @param {Function} callbackFn - The callback function
 */
function loadFiles(paths, callbackFn, args) {
  // listify paths
  paths = paths.push ? paths : [paths];

  var numWaiting = paths.length,
      x = numWaiting,
      pathsNotFound = [],
      fn,
      i;

  // define callback function
  fn = function(path, result, defaultPrevented) {
    // handle error
    if (result == 'e') pathsNotFound.push(path);

    // handle beforeload event. If defaultPrevented then that means the load
    // will be blocked (ex. Ghostery/ABP on Safari)
    if (result == 'b') {
      if (defaultPrevented) pathsNotFound.push(path);
      else return;
    }

    numWaiting--;
    if (!numWaiting) callbackFn(pathsNotFound);
  };

  // load scripts
  for (i=0; i < x; i++) loadFile(paths[i], fn, args);
}


/**
 * Initiate script load and register bundle.
 * @param {(string|string[])} paths - The file paths
 * @param {(string|Function|Object)} [arg1] - The (1) bundleId or (2) success
 *   callback or (3) object literal with success/error arguments, numRetries,
 *   etc.
 * @param {(Function|Object)} [arg2] - The (1) success callback or (2) object
 *   literal with success/error arguments, numRetries, etc.
 */
function loadjs(paths, arg1, arg2) {
  var bundleId,
      args;

  // bundleId (if string)
  if (arg1 && arg1.trim) bundleId = arg1;

  // args (default is {})
  args = (bundleId ? arg2 : arg1) || {};

  // throw error if bundle is already defined
  if (bundleId) {
    if (bundleId in bundleIdCache) {
      throw "LoadJS";
    } else {
      bundleIdCache[bundleId] = true;
    }
  }

  function loadFn(resolve, reject) {
    loadFiles(paths, function (pathsNotFound) {
      // execute callbacks
      executeCallbacks(args, pathsNotFound);
      
      // resolve Promise
      if (resolve) {
        executeCallbacks({success: resolve, error: reject}, pathsNotFound);
      }

      // publish bundle load event
      publish(bundleId, pathsNotFound);
    }, args);
  }
  
  if (args.returnPromise) return new Promise(loadFn);
  else loadFn();
}


/**
 * Execute callbacks when dependencies have been satisfied.
 * @param {(string|string[])} deps - List of bundle ids
 * @param {Object} args - success/error arguments
 */
loadjs.ready = function ready(deps, args) {
  // subscribe to bundle load event
  subscribe(deps, function (depsNotFound) {
    // execute callbacks
    executeCallbacks(args, depsNotFound);
  });

  return loadjs;
};


/**
 * Manually satisfy bundle dependencies.
 * @param {string} bundleId - The bundle id
 */
loadjs.done = function done(bundleId) {
  publish(bundleId, []);
};


/**
 * Reset loadjs dependencies statuses
 */
loadjs.reset = function reset() {
  bundleIdCache = {};
  bundleResultCache = {};
  bundleCallbackQueue = {};
};


/**
 * Determine if bundle has already been defined
 * @param String} bundleId - The bundle id
 */
loadjs.isDefined = function isDefined(bundleId) {
  return bundleId in bundleIdCache;
};


// export
return loadjs;

}));


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(3);


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "eagerLoadTwitterLibrary", function() { return /* reexport */ loadTwitterLibrary; });
__webpack_require__.d(__webpack_exports__, "Follow", function() { return /* binding */ src_Follow; });
__webpack_require__.d(__webpack_exports__, "Hashtag", function() { return /* binding */ src_Hashtag; });
__webpack_require__.d(__webpack_exports__, "Mention", function() { return /* binding */ src_Mention; });
__webpack_require__.d(__webpack_exports__, "Share", function() { return /* binding */ src_Share; });
__webpack_require__.d(__webpack_exports__, "Timeline", function() { return /* binding */ src_Timeline; });
__webpack_require__.d(__webpack_exports__, "Tweet", function() { return /* binding */ src_Tweet; });

// EXTERNAL MODULE: external {"root":"React","commonjs2":"react","commonjs":"react","amd":"react"}
var external_root_React_commonjs2_react_commonjs_react_amd_react_ = __webpack_require__(0);
var external_root_React_commonjs2_react_commonjs_react_amd_react_default = /*#__PURE__*/__webpack_require__.n(external_root_React_commonjs2_react_commonjs_react_amd_react_);

// EXTERNAL MODULE: ./node_modules/loadjs/dist/loadjs.umd.js
var loadjs_umd = __webpack_require__(1);
var loadjs_umd_default = /*#__PURE__*/__webpack_require__.n(loadjs_umd);

// CONCATENATED MODULE: ./src/utils.js


var twScriptUrl = "https://platform.twitter.com/widgets.js";
var twScriptWindowFieldName = "twttr";
var twScriptName = twScriptWindowFieldName;
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function loadTwitterLibrary() {
  if (!loadjs_umd_default.a.isDefined(twScriptName)) {
    loadjs_umd_default()(twScriptUrl, twScriptName);
  }
}
function twWidgetFactory() {
  return new Promise(function (resolve, reject) {
    var rejectWithError = function rejectWithError() {
      return reject(new Error("Could not load remote twitter widgets js"));
    };

    loadTwitterLibrary();
    loadjs_umd_default.a.ready(twScriptName, {
      success: function success() {
        // Ensure loaded
        var twttr = window[twScriptWindowFieldName];

        if (!twttr || !twttr.widgets) {
          rejectWithError();
        }

        resolve(twttr.widgets);
      },
      error: rejectWithError
    });
  });
}
function removeChildrenWithAttribute(node, attribute) {
  if (node) {
    node.querySelectorAll("*").forEach(function (child) {
      if (child.hasAttribute(attribute)) {
        child.remove();
      }
    });
  }
}

function is(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function isShallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  for (var i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

function useShallowCompareMemoize(value) {
  var ref = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_["useRef"])();

  if (!isShallowEqual(value, ref.current)) {
    ref.current = value;
  }

  return ref.current;
}
function cloneShallow(value) {
  return typeof value === "object" ? Object.assign({}, value) : value;
}
// CONCATENATED MODULE: ./src/index.js



var childDivIdentifyingAttribute = "twdiv";

function useTwitterWidget(factoryFunctionName, primaryArg, options, onLoad) {
  var _useState = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_["useState"])(null),
      error = _useState[0],
      setError = _useState[1];

  var ref = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_["useRef"])(null); // noop if ssr

  if (!canUseDOM) {
    return {
      ref: ref,
      error: error
    };
  } // Make deps for useEffect.
  // options, and possibly primaryArg, are objects that should be compared (shallow).
  // There currently aren't any nested arrays or objects, so they
  // can be cloned in a shallow manner.
  // NOTE onLoad is used in useCallback, but it is not listed as a dependency.
  // Listing it would likely cause unnecessary loads. The latest onLoad should be
  // used regardless, since it will not be called unless the other dependencies
  // change, so it works out.


  var deps = [factoryFunctionName, useShallowCompareMemoize(primaryArg), useShallowCompareMemoize(options)];
  Object(external_root_React_commonjs2_react_commonjs_react_amd_react_["useEffect"])(function () {
    // Reset error
    setError(null); // Protect against race conditions
    // (set to true in cleanup function;
    // checked if canceled in async loadWidget)

    var isCanceled = false;

    if (ref.current) {
      removeChildrenWithAttribute(ref.current, childDivIdentifyingAttribute);

      if (!ref || !ref.current) {
        return;
      }

      var childEl = document.createElement("div");
      childEl.setAttribute(childDivIdentifyingAttribute, "yes");
      ref.current.appendChild(childEl);
      twWidgetFactory().then(function (wf) {
        // primaryArg (possibly an object) and options must be cloned
        // since twitter mutates them (gah!).
        // There currently aren't any nested arrays or objects, so they
        // can be cloned in a shallow manner.
        return wf[factoryFunctionName](cloneShallow(primaryArg), childEl, cloneShallow(options));
      }).then(function (resultMaybe) {
        // Twitter returns undefined if widget creation fails.
        // However, if deps are stale (isCanceled), suppress error (likely race condition).
        if (!resultMaybe && !isCanceled) {
          throw new Error("Twitter could not create widget. If it is a Timeline or " + "Tweet, ensure the screenName/tweetId exists.");
        }

        if (!ref || !ref.current) {
          return;
        }

        if (isCanceled) {
          if (childEl) {
            childEl.remove();
          }

          return;
        }

        if (onLoad) {
          onLoad();
        }
      })["catch"](function (e) {
        console.error(e);
        setError(e);
      });
    }

    return function () {
      isCanceled = true;
    };
  }, deps);
  return {
    ref: ref,
    error: error
  };
}

var src_Follow = function Follow(_ref) {
  var username = _ref.username,
      options = _ref.options,
      onLoad = _ref.onLoad,
      renderError = _ref.renderError;

  var _useTwitterWidget = useTwitterWidget("createFollowButton", username, options, onLoad),
      ref = _useTwitterWidget.ref,
      error = _useTwitterWidget.error;

  return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement("div", {
    ref: ref
  }, error && renderError && renderError(error));
};
var src_Hashtag = function Hashtag(_ref2) {
  var hashtag = _ref2.hashtag,
      options = _ref2.options,
      onLoad = _ref2.onLoad,
      renderError = _ref2.renderError;

  var _useTwitterWidget2 = useTwitterWidget("createHashtagButton", hashtag, options, onLoad),
      ref = _useTwitterWidget2.ref,
      error = _useTwitterWidget2.error;

  return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement("div", {
    ref: ref
  }, error && renderError && renderError(error));
};
var src_Mention = function Mention(_ref3) {
  var username = _ref3.username,
      options = _ref3.options,
      onLoad = _ref3.onLoad,
      renderError = _ref3.renderError;

  var _useTwitterWidget3 = useTwitterWidget("createMentionButton", username, options, onLoad),
      ref = _useTwitterWidget3.ref,
      error = _useTwitterWidget3.error;

  return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement("div", {
    ref: ref
  }, error && renderError && renderError(error));
};
var src_Share = function Share(_ref4) {
  var url = _ref4.url,
      options = _ref4.options,
      onLoad = _ref4.onLoad,
      renderError = _ref4.renderError;

  var _useTwitterWidget4 = useTwitterWidget("createShareButton", url, options, onLoad),
      ref = _useTwitterWidget4.ref,
      error = _useTwitterWidget4.error;

  return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement("div", {
    ref: ref
  }, error && renderError && renderError(error));
};
var src_Timeline = function Timeline(_ref5) {
  var dataSource = _ref5.dataSource,
      options = _ref5.options,
      onLoad = _ref5.onLoad,
      renderError = _ref5.renderError;

  var _useTwitterWidget5 = useTwitterWidget("createTimeline", dataSource, options, onLoad),
      ref = _useTwitterWidget5.ref,
      error = _useTwitterWidget5.error;

  return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement("div", {
    ref: ref
  }, error && renderError && renderError(error));
};
var src_Tweet = function Tweet(_ref6) {
  var tweetId = _ref6.tweetId,
      options = _ref6.options,
      onLoad = _ref6.onLoad,
      renderError = _ref6.renderError;

  var _useTwitterWidget6 = useTwitterWidget("createTweet", tweetId, options, onLoad),
      ref = _useTwitterWidget6.ref,
      error = _useTwitterWidget6.error;

  return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement("div", {
    ref: ref
  }, error && renderError && renderError(error));
};

/***/ })
/******/ ])["default"];
});